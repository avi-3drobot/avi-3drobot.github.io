<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avi VOX Viewer - 3D Volumetric Inference</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #333333;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .viewer {
            flex: 1;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .controls {
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .control-group button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .control-group button:hover {
            background: #45a049;
        }

        .control-group button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .info {
            background: rgba(0, 0, 0, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .info h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }

        .info p {
            margin: 5px 0;
            font-size: 14px;
        }

        .frame-info {
            background: rgba(0, 0, 0, 0.05);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .frame-number {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            color: #333;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #4CAF50;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: rgba(255, 0, 0, 0.2);
            color: #ff6b6b;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .stats {
            background: rgba(0, 0, 0, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .stat-label {
            color: #333;
        }

        .stat-value {
            color: #4CAF50;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="info">
                <h3>Avi VOX Viewer</h3>
                <p>3D Volumetric Inference Visualization</p>
                <p>View the transformation sequence of 3D voxel models generated by the Avi system.</p>
            </div>

            <div class="frame-info">
                <div class="frame-number" id="frame-number">000</div>
                <div>Frame <span id="current-frame">0</span> of <span id="total-frames">20</span></div>
            </div>

            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Voxels:</span>
                    <span class="stat-value" id="voxel-count">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Size:</span>
                    <span class="stat-value" id="model-size">0x0x0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Colors:</span>
                    <span class="stat-value" id="color-count">0</span>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Frame Navigation</label>
                    <input type="range" id="frame-slider" min="0" max="19" value="0" step="1">
                    <div>
                        <button id="prev-frame" onclick="previousFrame()">‚èÆ Previous</button>
                        <button id="next-frame" onclick="nextFrame()">Next ‚è≠</button>
                    </div>
                    <div>
                        <button id="play-pause" onclick="togglePlay()">‚ñ∂ Play</button>
                        <button onclick="resetView()">üîÑ Reset View</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Playback Speed</label>
                    <input type="range" id="speed-slider" min="0.1" max="2" value="0.5" step="0.1">
                    <div>Speed: <span id="speed-value">0.5</span>x</div>
                </div>

                <div class="control-group">
                    <label>Display Options</label>
                    <div>
                        <button id="wireframe-btn" onclick="toggleWireframe()">Wireframe</button>
                        <button id="solid-btn" onclick="toggleSolid()">Solid</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Camera Controls</label>
                    <div>
                        <button onclick="resetCamera()">Reset Camera</button>
                        <button onclick="fitToView()">Fit to View</button>
                    </div>
                </div>
            </div>

            <div class="info">
                <h3>Controls</h3>
                <p>üñ±Ô∏è Left Click + Drag: Rotate</p>
                <p>üñ±Ô∏è Right Click + Drag: Pan</p>
                <p>üñ±Ô∏è Scroll: Zoom</p>
                <p>‚å®Ô∏è Space: Play/Pause</p>
                <p>‚å®Ô∏è Arrow Keys: Navigate Frames</p>
            </div>
        </div>

        <div class="viewer">
            <div id="canvas-container"></div>
            <div id="loading" class="loading" style="display: none;">
                <div class="spinner"></div>
                <div>Loading VOX file...</div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let currentVoxelGroup = null;
        let nextVoxelGroup = null;
        let currentFrame = 0;
        let totalFrames = 20;
        let isPlaying = false;
        let playInterval = null;
        let playbackSpeed = 0.5;
        let isWireframe = false;
        let isTransitioning = false;
        let transitionProgress = 0;
        let transitionDuration = 0.3; // seconds

        // VOX file frames
        const voxFiles = [
            '000.vox', '005.vox', '010.vox', '015.vox', '020.vox',
            '025.vox', '030.vox', '035.vox', '040.vox', '045.vox',
            '050.vox', '055.vox', '060.vox', '065.vox', '070.vox',
            '075.vox', '080.vox', '085.vox', '090.vox'
        ];
        
        // Preload cache for smoother navigation
        const voxelCache = new Map();

        // VOX file parser
        class VOXParser {
                    constructor() {
            this.voxels = [];
            this.palette = [];
            this.size = { x: 0, y: 0, z: 0 };
        }

            async parseVoxFile(url) {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const dataView = new DataView(arrayBuffer);
                    
                    // Check VOX magic number
                    const magic = this.readString(dataView, 0, 4);
                    if (magic !== 'VOX ') {
                        throw new Error('Invalid VOX file format');
                    }

                    // Read version
                    const version = dataView.getUint32(4, true);
                    
                    let offset = 8;
                    
                    // Read chunks
                    while (offset < arrayBuffer.byteLength) {
                        const chunkId = this.readString(dataView, offset, 4);
                        const chunkSize = dataView.getUint32(offset + 4, true);
                        const childChunks = dataView.getUint32(offset + 8, true);
                        offset += 12;

                        if (chunkId === 'SIZE') {
                            this.parseSizeChunk(dataView, offset);
                        } else if (chunkId === 'XYZI') {
                            this.parseVoxelChunk(dataView, offset, chunkSize);
                        } else if (chunkId === 'RGBA') {
                            this.parsePaletteChunk(dataView, offset);
                        }

                        offset += chunkSize;
                    }

                    return {
                        voxels: this.voxels,
                        palette: this.palette,
                        size: this.size
                    };
                } catch (error) {
                    console.error('Error parsing VOX file:', error);
                    return null;
                }
            }

            readString(dataView, offset, length) {
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += String.fromCharCode(dataView.getUint8(offset + i));
                }
                return result;
            }

            parseSizeChunk(dataView, offset) {
                this.size.x = dataView.getUint32(offset, true);
                this.size.y = dataView.getUint32(offset + 4, true);
                this.size.z = dataView.getUint32(offset + 8, true);
            }

            parseVoxelChunk(dataView, offset, chunkSize) {
                const numVoxels = dataView.getUint32(offset, true);
                offset += 4;

                for (let i = 0; i < numVoxels; i++) {
                    const x = dataView.getUint8(offset + i * 4);
                    const y = dataView.getUint8(offset + i * 4 + 1);
                    const z = dataView.getUint8(offset + i * 4 + 2);
                    const colorIndex = Math.max(0, dataView.getUint8(offset + i * 4 + 3) - 1);
                    
                    this.voxels.push({ x, y, z, colorIndex });
                }
            }

            parsePaletteChunk(dataView, offset) {
                for (let i = 0; i < 256; i++) {
                    const r = dataView.getUint8(offset + i * 4);
                    const g = dataView.getUint8(offset + i * 4 + 1);
                    const b = dataView.getUint8(offset + i * 4 + 2);
                    const a = dataView.getUint8(offset + i * 4 + 3);
                    
                    this.palette.push({ r, g, b, a });
                }
            }
        }

        // Initialize the viewer
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 50, 50);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth - 300, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance

            // Add renderer to container
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = true;
            controls.enableZoom = true;
            controls.enableRotate = true;
            controls.maxDistance = 200;
            controls.minDistance = 5;

            // Add lighting
            addLighting();

            // Add grid
            addGrid();

            // Load first frame
            loadVoxFile(0);

            // Add event listeners
            addEventListeners();

            // Start render loop
            animate();
        }

        function addLighting() {
            // Ambient light - slightly dimmer
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Directional light - slightly dimmer
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Additional directional light from opposite direction
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight2.position.set(-50, -50, -50);
            scene.add(directionalLight2);

            // Point light - slightly dimmer
            const pointLight = new THREE.PointLight(0x4CAF50, 0.6, 150);
            pointLight.position.set(-50, 50, -50);
            scene.add(pointLight);

            // Additional point light for better coverage
            const pointLight2 = new THREE.PointLight(0xffffff, 0.4, 100);
            pointLight2.position.set(50, -50, 50);
            scene.add(pointLight2);
        }

        function addGrid() {
            const gridHelper = new THREE.GridHelper(100, 20, 0xcccccc, 0x999999);
            scene.add(gridHelper);
        }

        function addEventListeners() {
            // Frame slider
            document.getElementById('frame-slider').addEventListener('input', function(e) {
                currentFrame = parseInt(e.target.value);
                loadVoxFile(currentFrame);
                updateUI();
            });

            // Speed slider
            document.getElementById('speed-slider').addEventListener('input', function(e) {
                playbackSpeed = parseFloat(e.target.value);
                document.getElementById('speed-value').textContent = playbackSpeed.toFixed(1);
                if (isPlaying) {
                    startPlayback();
                }
            });

            // Keyboard controls
            document.addEventListener('keydown', function(e) {
                switch(e.code) {
                    case 'Space':
                        e.preventDefault();
                        togglePlay();
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        previousFrame();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        nextFrame();
                        break;
                }
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        async function loadVoxFile(frameIndex) {
            if (frameIndex < 0 || frameIndex >= voxFiles.length) return;

            showLoading(true);

            const voxFile = voxFiles[frameIndex];
            const url = `./voxels/${voxFile}`;

            try {
                let voxData;
                
                // Check cache first
                if (voxelCache.has(frameIndex)) {
                    voxData = voxelCache.get(frameIndex);
                } else {
                    // Parse and cache
                    const parser = new VOXParser();
                    voxData = await parser.parseVoxFile(url);
                    voxelCache.set(frameIndex, voxData);
                    
                    // Preload next frame for smoother navigation
                    const nextIndex = frameIndex + 1;
                    if (nextIndex < voxFiles.length && !voxelCache.has(nextIndex)) {
                        preloadFrame(nextIndex);
                    }
                }
                
                if (voxData && voxData.voxels && voxData.voxels.length > 0) {
                    createVoxelModel(voxData, true);
                } else {
                    console.log('No valid voxel data, using placeholder');
                    // Fallback to placeholder if parsing fails
                    createVoxelPlaceholder(frameIndex, true);
                }
            } catch (error) {
                console.error('Error loading VOX file:', error);
                // Fallback to placeholder
                createVoxelPlaceholder(frameIndex, true);
            }

            showLoading(false);
            updateUI();
        }

        async function preloadFrame(frameIndex) {
            if (frameIndex < 0 || frameIndex >= voxFiles.length) return;
            
            const voxFile = voxFiles[frameIndex];
            const url = `./voxels/${voxFile}`;
            
            try {
                const parser = new VOXParser();
                const voxData = await parser.parseVoxFile(url);
                voxelCache.set(frameIndex, voxData);
            } catch (error) {
                console.log(`Failed to preload frame ${frameIndex}:`, error);
            }
        }

        function createVoxelModel(voxData, useTransition = false) {
            // Create a group for all voxels
            const newVoxelGroup = new THREE.Group();

            const voxelSize = 1;
            const centerX = voxData.size.x / 2;
            const centerY = voxData.size.y / 2;
            const centerZ = voxData.size.z / 2;

            // Group voxels by color for instanced rendering
            const colorGroups = {};
            
            voxData.voxels.forEach(voxel => {
                const colorKey = voxel.colorIndex.toString();
                if (!colorGroups[colorKey]) {
                    colorGroups[colorKey] = [];
                }
                colorGroups[colorKey].push(voxel);
            });

            // Create instanced meshes for each color group
            Object.keys(colorGroups).forEach(colorKey => {
                const voxels = colorGroups[colorKey];
                const colorIndex = parseInt(colorKey);
                
                // Get color from palette
                let color;
                if (voxData.palette && voxData.palette[colorIndex]) {
                    const paletteColor = voxData.palette[colorIndex];
                    color = new THREE.Color(
                        paletteColor.r / 255,
                        paletteColor.g / 255,
                        paletteColor.b / 255
                    );
                } else {
                    // Default color if no palette
                    color = new THREE.Color().setHSL(colorIndex / 255, 0.8, 0.6);
                }

                // Create geometry and material for this color group
                const geometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
                const material = new THREE.MeshLambertMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });

                if (isWireframe) {
                    material.wireframe = true;
                    material.wireframeLinewidth = 1;
                }

                // Create instanced mesh for this color group
                const instancedMesh = new THREE.InstancedMesh(geometry, material, voxels.length);
                instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                
                // Set positions for all instances (Y-axis up)
                const matrix = new THREE.Matrix4();
                voxels.forEach((voxel, index) => {
                    matrix.setPosition(
                        (voxel.x - centerX) * voxelSize,
                        (voxel.z - centerZ) * voxelSize,
                        -(voxel.y - centerY) * voxelSize
                    );
                    instancedMesh.setMatrixAt(index, matrix);
                });
                
                instancedMesh.castShadow = true;
                instancedMesh.receiveShadow = true;
                newVoxelGroup.add(instancedMesh);
            });

            // Handle smooth transitions
            if (useTransition && currentVoxelGroup) {
                // Start transition
                nextVoxelGroup = newVoxelGroup;
                nextVoxelGroup.children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = 0;
                    }
                });
                scene.add(nextVoxelGroup);
                isTransitioning = true;
                transitionProgress = 0;
            } else {
                // Direct replacement
                if (currentVoxelGroup) {
                    scene.remove(currentVoxelGroup);
                }
                currentVoxelGroup = newVoxelGroup;
                scene.add(currentVoxelGroup);
            }

            // Update stats
            updateStats(voxData);
        }

        function createVoxelPlaceholder(frameIndex, useTransition = false) {
            // Create a group for all voxels
            const newVoxelGroup = new THREE.Group();

            // Create a simple voxel structure based on frame index
            const voxelSize = 1;
            const gridSize = 20;
            const center = gridSize / 2;

            // Create a pattern that changes with the frame
            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    for (let z = 0; z < gridSize; z++) {
                        // Create a pattern that transforms over frames
                        const distance = Math.sqrt((x - center) ** 2 + (y - center) ** 2 + (z - center) ** 2);
                        const frameOffset = frameIndex * 0.5;
                        
                        if (distance < 8 + frameOffset && distance > 3 - frameOffset) {
                            const geometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
                            
                            // Create color based on position and frame
                            const hue = (frameIndex / totalFrames) * 0.3 + (distance / 15) * 0.7;
                            const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
                            
                            const material = new THREE.MeshLambertMaterial({ 
                                color: color,
                                transparent: true,
                                opacity: 0.8
                            });

                            if (isWireframe) {
                                material.wireframe = true;
                                material.wireframeLinewidth = 1;
                            }

                            const voxel = new THREE.Mesh(geometry, material);
                            voxel.position.set(
                                (x - center) * voxelSize,
                                (z - center) * voxelSize,
                                -(y - center) * voxelSize
                            );
                            voxel.castShadow = true;
                            voxel.receiveShadow = true;

                            newVoxelGroup.add(voxel);
                        }
                    }
                }
            }

            // Handle smooth transitions
            if (useTransition && currentVoxelGroup) {
                // Start transition
                nextVoxelGroup = newVoxelGroup;
                nextVoxelGroup.children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = 0;
                    }
                });
                scene.add(nextVoxelGroup);
                isTransitioning = true;
                transitionProgress = 0;
            } else {
                // Direct replacement
                if (currentVoxelGroup) {
                    scene.remove(currentVoxelGroup);
                }
                currentVoxelGroup = newVoxelGroup;
                scene.add(currentVoxelGroup);
            }

            // Update stats for placeholder
            updateStats({
                voxels: newVoxelGroup.children,
                size: { x: gridSize, y: gridSize, z: gridSize },
                palette: []
            });
        }

        function updateStats(voxData) {
            document.getElementById('voxel-count').textContent = voxData.voxels.length;
            document.getElementById('model-size').textContent = `${voxData.size.x}x${voxData.size.y}x${voxData.size.z}`;
            document.getElementById('color-count').textContent = voxData.palette.length || 'N/A';
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        function updateUI() {
            document.getElementById('frame-number').textContent = voxFiles[currentFrame].replace('.vox', '');
            document.getElementById('current-frame').textContent = currentFrame + 1;
            document.getElementById('total-frames').textContent = totalFrames;
            document.getElementById('frame-slider').value = currentFrame;
        }

        function nextFrame() {
            if (currentFrame < totalFrames - 1) {
                currentFrame++;
                loadVoxFile(currentFrame);
            }
        }

        function previousFrame() {
            if (currentFrame > 0) {
                currentFrame--;
                loadVoxFile(currentFrame);
            }
        }

        function togglePlay() {
            if (isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        function startPlayback() {
            isPlaying = true;
            document.getElementById('play-pause').textContent = '‚è∏ Pause';
            playInterval = setInterval(() => {
                if (currentFrame >= totalFrames - 1) {
                    currentFrame = 0;
                } else {
                    currentFrame++;
                }
                loadVoxFile(currentFrame);
            }, 1000 / playbackSpeed);
        }

        function stopPlayback() {
            isPlaying = false;
            document.getElementById('play-pause').textContent = '‚ñ∂ Play';
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            if (currentVoxelGroup) {
                currentVoxelGroup.children.forEach(child => {
                    if (child.material) {
                        child.material.wireframe = isWireframe;
                    }
                });
            }
            document.getElementById('wireframe-btn').style.background = isWireframe ? '#45a049' : '#4CAF50';
        }

        function toggleSolid() {
            isWireframe = false;
            if (currentVoxelGroup) {
                currentVoxelGroup.children.forEach(child => {
                    if (child.material) {
                        child.material.wireframe = false;
                    }
                });
            }
            document.getElementById('wireframe-btn').style.background = '#4CAF50';
        }

        function resetView() {
            if (currentVoxelGroup) {
                currentVoxelGroup.rotation.set(0, 0, 0);
            }
        }

        function resetCamera() {
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            controls.reset();
        }

        function fitToView() {
            if (currentVoxelGroup) {
                const box = new THREE.Box3().setFromObject(currentVoxelGroup);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5; // Add some padding
                camera.position.set(center.x, center.y, center.z + cameraZ);
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();
            }
        }

        function onWindowResize() {
            camera.aspect = (window.innerWidth - 300) / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - 300, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Handle smooth transitions
            if (isTransitioning && nextVoxelGroup) {
                transitionProgress += 0.016 / transitionDuration; // Assuming 60fps
                
                if (transitionProgress >= 1) {
                    // Transition complete
                    if (currentVoxelGroup) {
                        scene.remove(currentVoxelGroup);
                    }
                    currentVoxelGroup = nextVoxelGroup;
                    nextVoxelGroup = null;
                    isTransitioning = false;
                    transitionProgress = 0;
                } else {
                    // Smooth fade transition
                    if (currentVoxelGroup) {
                        currentVoxelGroup.children.forEach(child => {
                            if (child.material) {
                                child.material.opacity = 1 - transitionProgress;
                            }
                        });
                    }
                    if (nextVoxelGroup) {
                        nextVoxelGroup.children.forEach(child => {
                            if (child.material) {
                                child.material.opacity = transitionProgress;
                            }
                        });
                    }
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
